#!/usr/bin/env python3

import argparse
import re
import sys
import regex
import time
import yaml

sys.path.append('../itermae')
import itermae

# Using argparse module to define the arguments

# Name and description of this program
parser = argparse.ArgumentParser(description=""+
    "itermae - iteratively chop up sequences using fuzzy regular expressions. "+
    "There is no parallelization internal to this script, so for practical "+
    "performance you should use multiple files or stream in chunks via "+
    "STDIN. I recommend you use the later, with GNU parallel, see examples "+
    "in the README.")

# Input determination 
parser.add_argument("-i","--input",default="STDIN",
    help="Where the input reads are. The default is standard input "+
        "( 'STDIN' ), but this can also be a filepath to read. ")
# Is it gzip'd ?
parser.add_argument("-z","--gzipped",action="store_true",
    help="Use this flag if the input is a gzipped file.")
# Input format
parser.add_argument("-if","--input-format",default='fastq',
    help="What format the input is. Default is 'FASTQ'. I expect this, or "+
        "'SAM', 'FASTA', or 'txt', case insensitive.")

# Output determination
parser.add_argument("--output",default="STDOUT",
    help="Where to output matches to. The recommended default is standard out "+
        "( 'STDOUT' ), but this can also be a filepath to write. ")
parser.add_argument("-of","--output-format",default='sam',
    help="What format the output should be in. Default is an unmapped SAM "+
        "('SAM'), also available are 'FASTQ' and 'FASTA', case insensitive.")
parser.add_argument("-f","--failed",default=None,
    help="Optional filepath for writing a file passing-through the reads that "+
        "failed at any stage of matching, filtering, or forming outputs. Can "+
        "also be directed to 'STDOUT' or 'STDERR'.")
parser.add_argument("-r","--report",default=None,
    help="Optional filepath for writing a report of read-level statistics. "+
        "This is heavy disk usage, but useful for debugging runs with a "+
        "limit (see '--limit') set.")

# verbosity
parser.add_argument("-v","--verbose",action="count",default=0,
    help="Level of information to pipe out to STDERR. "+
        "None is nothing, "+
        "-v is setup messages and start-stop messsages, "+
        "-v -v is read-level details, "+
        "-v -v -v is operation-level details.")

### CLI operation and output specification
# Operations
parser.add_argument("-o","--operation",action="append",
    help="The operation of matching and extracting. For details about syntax, "+
        "please refer to the README, documentation, and tutorials, and the "+
        "regex module documentation about writing fuzzy regexes. "+
        "\n\n"+
        "Each operation has a named input group, then a pattern using named "+
        "capture groups. The input sequence read is called 'input', and is a "+
        "reserved name (as is 'dummyspacer', reserved for output forming). "+
        "Each operation is done in the order you specify, so later "+
        "operations can use previous matching groups as inputs. "+
        "\n\n"+
        "Importantly, all input sequences are converted to uppercase, so "+
        "write all regex in uppercase. The alphabet is unrestricted but "+
        "untested beyond ATCGN.")
# Filter specification
parser.add_argument("-f","--filter",action="append",
    help="Filters to prevent output of reads that do not pass a criteria. "+
        "These must evaluate to True or False (in python), and can use "+
        "some attributes of the matches or matched groups. The 'statistics' "+
        "package is loaded to permit using summary statistics of these "+
        "properties. For examples, "+
        "'umi.length == 5', 'statistics.mean(barcode.quality)',  "+
        "'sample_barcode == \"TTCAC\"'. See tutorial/documentation for more.")

# Outputs
parser.add_argument("-oid","--output-id",action="append",
    help="Each specification of record IDs to output, per read. "+
        "These should evaluate to a string in python, and you can access "+
        "properties of the input and matched groups such as 'input.id' or "+
        "'umi+seq', and combine these like 'input.id+\"_\"+umi.seq'. " 
        "to append the index sequence to the FASTQ ID. "+
        "Multiple arguments of this can be supplied, will be output in "+
        "the same file, and if output in SAM will have a tag 'IE:Z' "+
        "specifying which output it is.")

parser.add_argument("-oseq","--output-seq",action="append",
    help="Each specification of record sequences to output, per read. "+
        "This must be in the same order as the record IDs, as they are "+
        "paired. This is evaluated to form a BioPython SeqRecords, so "+
        "can be assembled by combining the names of matched groups with "+
        "plus-signs. For example, 'sample+barcode+umi' would append the "+
        "sequence of these three groups together. "+
        "'dummyspacer' is also available to insert an 'X' for "+
        "use in later parsing.")

parser.add_argument("--config",default=False,
    help="Optional config file. If specified, overrules all other relevant "+
        "arguements. See examples/docs.")

### Parse the arguments, check them.

args = parser.parse_args()

def check_reserved_name(name,reserved_names=['dummyspacer','input']):
    if name in reserved_names:
        print("Hey, you can't name a capture group "+
#            (" or ".join(reserved_names[ (i == name) for i in reserved_names]))+
            ", I'm using that/those! Pick a different name.",
            file=sys.stderr)
        exit(1)
    return 0

# from http://www.bioinformatics.org/sms/iupac.html
iupac_codes = {
    'A':'A',
    'C':'C',
    'T':'T',
    'G':'G',
    'R':'[AG]',
    'Y':'[CT]',
    'S':'[GC]',
    'W':'[AT]',
    'K':'[GT]',
    'M':'[AC]',
    'B':'[CGT]',
    'D':'[AGT]',
    'H':'[ACT]',
    'V':'[ACG]',
    'N':'[ATCGN]'
}


def config_from_file(file_path):
    configuration = {}

    # Verbosely attempt to read it, and I want a hard exit if it's not parsed
    try:
        with open(args.config,'r') as f:
            config = yaml.load(f,Loader=yaml.SafeLoader)
    except:
        print('I failed to parse the supplied YAML file path name.',
            file=sys.stderr)
        exit(1)

    # Looking for verbosity instruction global, if not that then in outputs
    try:
        try:
            verbosity = config['verbosity']
        except:
            verbosity = config['output']['verbosity']
    except:
        verbosity = 0 # else, just keep it bottled it up and tell no one 0_0
    configuration['verbosity'] = verbosity

    try:
        operations_array = []
        for each in config['operations']:
            if verbosity >= 1:
                print("Processing taking '"+each['use']+"'. \n",end="",file=sys.stderr)
            regex_groups = dict()
            group_order = list()
            for character, mark in zip(each['pattern'],each['marking']):
                if mark not in group_order:
                    group_order.append(mark)
                try:
                    regex_groups[mark] += iupac_codes[character]
                except:
                    regex_groups[mark] = iupac_codes[character]
            regex_string = ''
            i = 0
            for mark in group_order:
                if 'name_as' in each['marked_groups'][mark].keys():
                    check_reserved_name(each['marked_groups'][mark]['name_as'])
                else:
                    each['marked_groups'][mark]['name_as'] = "untitled_group"+str(i)
                    i += 1
                if verbosity >= 1:
                    print("    Found group '"+mark+"' with pattern '"+regex_groups[mark]+"'",end="",file=sys.stderr)
                try: 
                    if 'repeat_min' not in each['marked_groups'][mark].keys():
                        each['marked_groups'][mark]['repeat_min'] = each['marked_groups'][mark]['repeat']
                    if 'repeat_max' not in each['marked_groups'][mark].keys():
                        each['marked_groups'][mark]['repeat_max'] = each['marked_groups'][mark]['repeat']
                    regex_groups[mark] = (regex_groups[mark]+
                        '{'+str(each['marked_groups'][mark]['repeat_min'])+','+
                            str(each['marked_groups'][mark]['repeat_max'])+'}'
                        )
                    if verbosity >= 1:
                        print(", repeated between "+
                            str(each['marked_groups'][mark]['repeat_min'])+
                            " and "+
                            str(each['marked_groups'][mark]['repeat_max'])+
                            " times",end="",file=sys.stderr)
                except:
                    pass
                error_array = []
                try: 
                    error_array.append(
                        "e<="+str(each['marked_groups'][mark]['allowed_errors']) )
                except:
                    pass
                try: 
                    error_array.append(
                        "i<="+str(each['marked_groups'][mark]['allowed_insertions']) )
                except:
                    pass
                try: 
                    error_array.append(
                        "d<="+str(each['marked_groups'][mark]['allowed_deletions']) )
                except:
                    pass
                try: 
                    error_array.append(
                        "s<="+str(each['marked_groups'][mark]['allowed_substitutions']) )
                except:
                    pass
                if len(error_array):
                    error_string = "{"+','.join(error_array)+"}"
                else:
                    error_string = ""
                if verbosity >= 1:
                    print(".\n",end="",file=sys.stderr)
                regex_string += ( "(?<"+
                    each['marked_groups'][mark]['name_as']+
                    ">"+regex_groups[mark]+")"+error_string )
            compiled_regex = regex.compile( regex_string, regex.BESTMATCH )
            operations_array.append( [each['use'], compiled_regex] )
    except:
        print("I failed to build operations array from the arguments supplied.",
            file=sys.stderr)
        exit(1)
    configuration['operations'] = operations_array

    try:
        print("Processing output specifications.",file=sys.stderr)
        output_list = config['output']['list'] # I do need some outputs
        outputs_array = [] 
        i = 0 # this is for naming untitled outputs sequentially
        for each in output_list:
            if each['id'] is None:
                each['id'] = 'input.id' # default, the input.id
            if each['name'] is None:
                each['name'] = 'untitled_output_'+str(i)
                i += 1
            if each['filter'] is None:
                each['filter'] = 'True' # so will pass if not provided
            if verbosity >= 1:
                print("    Parsing output specification of '"+each['name']+"', "+
                    "ID is '"+each['id']+"', filter outputs it if '"+
                    each['filter']+"', with sequence derived of '"+
                    each['seq']+"'.",file=sys.stderr)
            outputs_array.append( {
                    'name':each['name'],
                    'filter':compile('True','<string>','eval',optimize=2),
                    'id':compile(each['id'],'<string>','eval',optimize=2),
                    'seq':compile(each['seq'],'<string>','eval',optimize=2)
                })
    except:
        print("I failed to build outputs array from the arguments supplied.",
            file=sys.stderr)
        exit(1)
    configuration['outputs'] = outputs_array

    try:
        configuration['input'] = config['input']['from']
    except:
        configuration['input'] = 'STDIN'
    try:
        configuration['input_format'] = config['input']['format']
    except:
        configuration['input_format'] = 'fastq'
    try:
        configuration['input_gzipped'] = config['input']['gzipped']
    except:
        configuration['input_gzipped'] = False

    try:
        configuration['output'] = config['output']['to']
    except:
        configuration['output'] = 'STDOUT'
    try:
        configuration['output_format'] = config['output']['format']
    except:
        configuration['output_format'] = 'sam'
    try:
        configuration['failed'] = config['output']['failed']
    except:
        configuration['failed'] = None
    try:
        configuration['report'] = config['output']['report']
    except:
        configuration['report'] = None

    return configuration


def config_from_args(args_copy):
    configuration = {}

    verbosity = args_copy.verbose
    configuration['verbosity'] = verbosity

    try:
        operations_array = []
        for each in operations:

            for capture_name in re.findall('<(.*?)>',each):
                print(capture_name)
                check_reserved_name(capture_name)
    
            (input_string, regex_string) = re.split("\s>\s",each.strip())
            compiled_regex = regex.compile(
                regex_string.strip(), # We use this regex
                regex.BESTMATCH # And we use the BESTMATCH strategy, I think
                )
            operations_array.append( [input_string.strip(), compiled_regex] )
    except:
        print("I failed to build operations array from the arguments supplied.",
            file=sys.stderr)
        exit(1)
    configuration['operations'] = operations_array

    try:
        outputs_array = [] 
        for i in range(len(output_seqs)):
            if output_ids is None:
                # or, use the default of input ID
                outputs_array.append( [
                        compile("input.id",'<string>','eval',optimize=2), 
                        compile(output_seqs[i],'<string>','eval',optimize=2) 
                        ])
            else:
                # append that to the outputs array
                outputs_array.append( [
                        compile(output_ids[i],'<string>','eval'), 
                        compile(output_seqs[i],'<string>','eval') 
                        ])
    except:
        print("I failed to build outputs array from the arguments supplied.",
            file=sys.stderr)
        exit(1)
    configuration['output'] = outputs_array
    
    configuration['input'] = args_copy.input
    configuration['input_gzipped'] = args_copy.gzipped
    configuration['input_format'] = args_copy.input_format
 
#if args.input == "STDIN" and args.gzipped:
#    print("I can't handle gzipped inputs on STDIN ! Un-gzip for me. "+
#        "Or write to a file, and point me that-a-way.",file=sys.stderr) 
#    exit(1)
#
#if configuration['verbosity'] >= 1:
#    print("\n["+str(time.time())+"] : "+
#        "I'm reading in a "+args.input_format+" format file, "+
#        " applying these operations of matching:\n",file=sys.stderr)
#    for each in operations_array:
#        print("  - from : "+each[0]+"\n"+
#            "    extract groups with regex : '"+str(each[1]),
#            file=sys.stderr)
#
#if args.verbose >= 1:
#    print("\n["+str(time.time())+"] : ...and with these filters:\n",
#        file=sys.stderr)
#    try:
#        for i in args.filter:
#            print("  - "+i,file=sys.stderr)
#    except:
#        print("  ( no filters defined )",file=sys.stderr)
#
#if args.verbose >= 1:
#    print("\n["+str(time.time())+"] : "+
#        "Then I'm going to construct outputs that look like:\n",
#        file=sys.stderr)
#    if args.output_id is None:
#        oids = ["input.id"]
#    else:
#        oids = args.output_id
#    for oid, oseq in zip(oids,args.output_seq):
#        print("  - With ID of : "+oid+"\n"+
#            "    and the sequence is the group(s) : "+oseq,file=sys.stderr)
#
#filter_array = []
## If it's omitted, we believe that means no filter, and we make it True
## because it gets `eval`'d in the function. 
#try:
#    for i in args.filter:
#        filter_array.append( compile(i,'<string>','eval',optimize=2) )
#except:
#    filter_array.append( compile('True','<string>','eval',optimize=2) )

#   if args.verbose >= 1:
#    print("\n["+str(time.time())+"] : Then, I'm going to write out a "+
#        args.output_format+" format file to "+
#        args.output+"",file=sys.stderr)
#    if args.report is not None:
#        print("\n["+str(time.time())+"] : and a report to '"+
#            vars(args)["report"]+".",file=sys.stderr)


    return configuration



if args.config:
    try: 
        configuration = config_from_file(args.config)
    except:
        print(" 1er nope")
        exit(1)

else:
    try:
        configuration = config_from_args(args)
    except:
        print("er nope")
        exit(1)

if configuration['verbosity'] >= 1:
    print('Configured as',file=sys.stderr)
    print('    '+configuration['input'],file=sys.stderr)
    print('    '+configuration['input_format'],file=sys.stderr)
    print('    '+str(configuration['input_gzipped']),file=sys.stderr)
    print('    '+configuration['output'],file=sys.stderr)
    print('    '+configuration['output_format'],file=sys.stderr)
    print('    '+configuration['failed'],file=sys.stderr)
    print('    '+configuration['report'],file=sys.stderr)
    print('    '+str(configuration['verbosity']),file=sys.stderr)
    print(configuration['operations'],file=sys.stderr)
    print(configuration['outputs'],file=sys.stderr)

if args.verbose >= 1:
    print("\n["+str(time.time())+"] : BEGIN RUNNING",file=sys.stderr)

itermae.reader(
    input_file=configuration['input'],
    in_format=configuration['input_format'],
    is_gzipped=configuration['input_gzipped'],
    output_file=configuration['output'],
    out_format=configuration['output_format'],
    failed_file=configuration['failed'],
    report_file=configuration['report'],
    operations_array=configuration['operations'],
    outputs_array=configuration['outputs'],
    verbosity=configuration['verbosity']
    )

if args.verbose >= 1:
    print("\n"+"["+str(time.time())+"]"+" : "+
        "All worked 'till the work is done --- or some fatal error.",
        file=sys.stderr)

exit(0)
